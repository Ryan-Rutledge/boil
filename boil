#!/usr/bin/env python3

import os
import sys
import stat
import argparse
from inspect import getsourcefile
sys.path.append(os.path.dirname(__file__))
import boiler


templateDirectory = 'plates'

def getTemplatePath():
    '''Returns path to boilerplate code templates.'''

    # Get path of current code
    source_file = os.path.abspath(getsourcefile(lambda:None))

    # Get directory of current code
    source_dir = os.path.split(source_file)[0]

    # Get directory of boilerplate templates
    return os.path.join(source_dir, templateDirectory)

def parse():
    # Main parser
    parser = argparse.ArgumentParser(description='Simple boilerplate code generator.')
    parser.add_argument('-l', '--lang', '--language', help='explicitly name a language to use (default: searches for a file extension match. If neither a language or a filename with an extension is provided, %{prog} will exit with error code 1)')

    # Generation parser
    options = parser.add_argument_group('code options')
    options.add_argument('-m', '--meth', '--method', action='append', default=[], help='generate empty method named METH (can be used multiple times)')
    options.add_argument('-f', '--force', action='store_true', help='Overwrite a file if one already exists (default: %{prog} will exit with an error code 2)')
    #options.add_argument('-t', '--tabs', '--tabwidth', type=int, help='expand tabs into a specific number of space characters (default: use tab characters)')

    # Output parser
    output = parser.add_argument_group('output options')
    output.add_argument('-x', '--exec', '--executable', action='store_true', help='attempts to make the file executable with chmod u+x')
    output.add_argument('file', nargs='?', help='boilerplate file to be created. Returns filename for piping (default: print code to stdout)')

    return vars(parser.parse_args())

def main():
    parser = parse()

    if parser.get('help'):
        parser.print_help()
    else:
        boiler.loadTemplates(getTemplatePath())

        filename = parser.get('file')
        text = boiler.plate(filename, parser)

        if filename:
            textfile = None

            # Write output to file
            if parser.get('force'):
                textfile = open(filename, 'w')
            else:
                try:
                    textfile = open(filename, 'x')
                except FileExistsError:
                    print('File already exists. Use -f to overwrite.')
                    sys.exit(2)

            print(text, end='', file=textfile)
            textfile.close()

            # Make file executable for user
            if parser.get('exec'):
                os.chmod(filename, stat.S_IMODE(os.stat(filename).st_mode) | stat.S_IXUSR)

            print(filename)
        else:
            print(text)

if __name__ == '__main__':
    main()
